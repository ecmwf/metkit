#pragma once

#include <algorithm>
#include <array>
#include <exception>
#include <string>
#include <string_view>


#include "eckit/exception/Exceptions.h"
#include "eckit/log/Log.h"

#include "metkit/config/LibMetkit.h"
#include "metkit/mars2grib/utils/mars2grib-exception.h"


namespace metkit::mars2grib::backend::deductions {

// TODO MIVAL: These tables should be generated by a python script
// from eccodes definitions at build time because they may change over time
// There is no known (to the author) automatic way to get these tables from eccodes directly
// or to set these values in grib messages via string or via eccodes API.
enum class SignificanceOfReferenceTime : uint8_t {
    Analysis             = 0,
    ForecastStart        = 1,
    ForecastVerification = 2,
    ObservationTime      = 3,
    LocalTime            = 4,
    SimulationStart      = 5,
    Missing              = 255
};


// grib2 section 1 octet 12 for significance of reference time (code Table 1.2)
template <class MarsDict_t, class ParDict_t>
SignificanceOfReferenceTime significanceOfReferenceTime(const MarsDict_t& mars, const ParDict_t& par) {

    using metkit::mars2grib::utils::dict_traits::get_or_throw;
    using metkit::mars2grib::utils::exceptions::Mars2GribDeductionException;

    try {

        // Get the mars.type
        auto marsType = get_or_throw<std::string>(mars, "type");

        constexpr std::array<std::string_view, 19> analysisTypes = {{"an", "ia", "oi", "3v", "4v", "3g", "4g", "ea",
                                                                     "4i", "pa", "tpa", "ga", "gai", "ai", "af", "ab",
                                                                     "oai", "ga", "gai"}};

        constexpr std::array<std::string_view, 33> forecastTypes = {
            {"fc",     "cf",    "pf",    "cm",      "fp",  "em",  "es",   "fa",   "efi",    "efic", "bf",
             "cd",     "me",    "wem",   "wes",     "cr",  "ses", "taem", "taes", "sg",     "sf",   "if",
             "fcmean", "fcmax", "fcmin", "fcstdev", "ssd", "tf",  "bf",   "cd",   "hcmean", "s3",   "si"}};

        if (std::any_of(analysisTypes.begin(), analysisTypes.end(), [&marsType](auto v) { return marsType == v; })) {
            return SignificanceOfReferenceTime::Analysis;
        }

        if (std::any_of(forecastTypes.begin(), forecastTypes.end(), [&marsType](auto v) { return marsType == v; })) {
            return SignificanceOfReferenceTime::ForecastStart;
        }

        // Unhandled cases
        throw Mars2GribDeductionException("Unable to deduce `significanceOfReferenceTime` from MARS type: " + marsType,
                                          Here());
    }
    catch (...) {
        std::throw_with_nested(Mars2GribDeductionException(
            "Could not deduce `significanceOfReferenceTime` from MARS dictionaries", Here()));
    }

    // Remove compiler warning
    __builtin_unreachable();
};

}  // namespace metkit::mars2grib::backend::deductions
